<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>trader_koo</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <style>
    :root {
      --bg: #0b0f16;
      --panel: #121927;
      --muted: #8ea0bd;
      --text: #e9eef8;
      --line: #25334f;
      --green: #38d39f;
      --red: #ff6b6b;
      --amber: #f8c24e;
      --blue: #6aa9ff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "JetBrains Mono", "IBM Plex Sans", ui-monospace, SFMono-Regular, Menlo, monospace;
      background: radial-gradient(1200px 600px at 10% -10%, #1d2740 0%, var(--bg) 45%);
      color: var(--text);
    }
    .wrap { max-width: 1360px; margin: 0 auto; padding: 24px; }

    /* ── Nav ── */
    nav {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 18px 0 16px;
      border-bottom: 1px solid var(--line);
      margin-bottom: 0;
      font-family: 'Inter', sans-serif;
    }
    .nav-logo {
      font-size: 17px;
      font-weight: 700;
      letter-spacing: .04em;
      color: var(--text);
      text-decoration: none;
    }
    .nav-links { display: flex; gap: 28px; }
    .nav-links a {
      color: var(--muted);
      text-decoration: none;
      font-size: 13.5px;
      letter-spacing: .02em;
      transition: color .2s;
    }
    .nav-links a:hover { color: var(--text); }

    /* ── Hero ── */
    .hero {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      gap: 18px;
      padding: 22px 0 20px;
      font-family: 'Inter', sans-serif;
    }
    .hero-title {
      font-size: clamp(30px, 6vw, 46px);
      font-weight: 700;
      line-height: 1.05;
      letter-spacing: -.03em;
      margin: 0 0 6px;
      background: linear-gradient(135deg, #e9eef8 28%, #6aa9ff 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .hero-sub {
      color: var(--muted);
      font-size: 14px;
      margin: 0;
      font-weight: 400;
    }
    .status-pill {
      border: 1px solid var(--line);
      background: var(--panel);
      border-radius: 999px;
      padding: 8px 14px;
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
      font-family: 'Inter', sans-serif;
    }
    input, select, button {
      width: 100%;
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 10px;
      outline: none;
    }
    .status { color: var(--muted); font-size: 0.9rem; }
    .tabs { display: flex; gap: 8px; margin-bottom: 14px; }
    .tab-btn {
      border: 1px solid var(--line);
      background: #0f1624;
      color: var(--muted);
      padding: 9px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
    }
    .tab-btn.active {
      color: white;
      background: linear-gradient(90deg, #1f7bff, #4e9cff);
      border: none;
    }
    .hidden { display: none; }
    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 10px;
    }
    .op-toolbar {
      display: grid;
      grid-template-columns: 170px 150px 150px 140px 170px minmax(170px, 1fr) 120px 120px;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
    }
    .preset-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 0 0 10px 0;
    }
    .preset-toolbar button {
      width: auto;
      padding: 8px 12px;
      border-radius: 9px;
      font-size: 0.82rem;
      background: #0f1624;
      color: var(--text);
      border: 1px solid var(--line);
      cursor: pointer;
    }
    .field { display: flex; flex-direction: column; gap: 4px; }
    .field label { color: var(--muted); font-size: 0.72rem; }
    .op-help {
      margin-bottom: 8px;
      padding: 8px 10px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: #0f1624;
    }
    .op-help-title {
      color: var(--text);
      font-size: 0.82rem;
      font-weight: 700;
      margin-bottom: 6px;
    }
    .op-help-grid {
      display: grid;
      grid-template-columns: 170px 1fr;
      gap: 6px 10px;
      align-items: start;
    }
    .op-help-key { color: var(--muted); font-size: 0.8rem; }
    .op-help-val { color: var(--text); font-size: 0.82rem; }
    .op-status {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      min-height: 34px;
      max-width: 100%;
      overflow-x: auto;
      padding: 2px 0;
    }
    .status-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid var(--line);
      background: #0f1624;
      color: var(--text);
      border-radius: 999px;
      padding: 5px 10px;
      font-size: 0.78rem;
      white-space: normal;
      word-break: break-word;
    }
    .status-chip .k { color: var(--muted); }
    .status-chip .v { color: var(--text); font-weight: 700; }
    .status-plain {
      color: var(--muted);
      font-size: 0.88rem;
    }
    .chart-toolbar {
      display: grid;
      grid-template-columns: 180px 150px 125px 125px 135px 135px 110px 75px 1fr;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
    }
    .cards {
      display: grid;
      grid-template-columns: repeat(6, minmax(120px, 1fr));
      gap: 10px;
      margin: 10px 0 14px;
    }
    .card {
      background: linear-gradient(180deg, #141d2f, #101726);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      min-height: 72px;
    }
    .label { color: var(--muted); font-size: 0.72rem; text-transform: uppercase; letter-spacing: 0.5px; }
    .value { font-size: 1.05rem; font-weight: 700; margin-top: 8px; }
    #chart { width: 100%; height: 760px; }
    table { width: 100%; border-collapse: collapse; font-size: 0.86rem; }
    th, td { border-bottom: 1px solid var(--line); padding: 8px; text-align: left; }
    th { color: var(--muted); font-weight: 600; }
    tr.clickable:hover { background: rgba(106,169,255,0.12); cursor: pointer; }
    .table-wrap { margin-top: 12px; display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 12px; }
    .table-wrap > .panel { min-width: 0; overflow-x: auto; }
    .mkt-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 8px;
      align-items: center;
    }
    .mkt-bar button {
      width: auto;
      padding: 5px 10px;
      border-radius: 8px;
      font-size: 0.78rem;
      background: #0f1624;
      color: var(--muted);
      border: 1px solid var(--line);
      cursor: pointer;
    }
    .mkt-bar button:hover { color: var(--text); border-color: var(--blue); }
    @media (max-width: 1100px) {
      .op-toolbar { display: flex; flex-wrap: wrap; gap: 8px; }
      .op-toolbar .field { flex: 1 1 140px; }
      .op-toolbar button { flex: 0 0 auto; width: auto; }
      .chart-toolbar { display: flex; flex-wrap: wrap; gap: 8px; }
      .chart-toolbar > * { flex: 1 1 130px; min-width: 0; }
      .chart-toolbar button { flex: 0 0 auto; width: auto; }
    }
    @media (max-width: 640px) {
      .wrap { padding: 12px; }
      #chart { height: 420px; }
      .table-wrap { grid-template-columns: 1fr; }
      .cards { grid-template-columns: repeat(3, 1fr); }
    }
    .guide {
      line-height: 1.5;
      color: var(--text);
      font-size: 0.92rem;
    }
    .guide h3 { margin: 8px 0 6px; font-size: 1rem; }
    .guide p { margin: 0 0 8px; color: var(--muted); }
  </style>
</head>
<body>
  <div class="wrap">
    <nav>
      <a class="nav-logo" href="https://kooexperience.com">HK</a>
      <div class="nav-links">
        <a href="https://kooexperience.com">Home</a>
        <a href="https://github.com/haomingkoo" target="_blank" rel="noopener">GitHub</a>
      </div>
    </nav>
    <section class="hero">
      <div>
        <h1 class="hero-title">trader_koo</h1>
        <p class="hero-sub">S&amp;P 500 swing dashboard — AI pattern detection, valuation screening, and after-close signals.</p>
      </div>
      <div id="serviceStatus" class="status-pill">Connecting...</div>
    </section>
    <div id="globalStatus" class="status" style="margin-bottom: 10px; font-size: 0.82rem;"></div>
    <input id="apiBase" type="hidden" value="" />


    <div class="tabs">
      <button id="tabGuideBtn" class="tab-btn active">Guide</button>
      <button id="tabOpBtn" class="tab-btn">Opportunities (PEG)</button>
      <button id="tabChartBtn" class="tab-btn">Chart + Levels</button>
      <button id="tabReportBtn" class="tab-btn">Daily Report</button>
    </div>

    <section id="tabOp" class="panel hidden">
      <div id="opFilterHelp" class="op-help">
        Default is full S&P500 universe. Use presets for quick screens, then sort/search table.
      </div>
      <div class="preset-toolbar">
        <button id="presetAllBtn" type="button">All S&P 500</button>
        <button id="presetUndervaluedBtn" type="button">Undervalued</button>
        <button id="presetDeepValueBtn" type="button">Deep Value</button>
        <button id="presetOvervaluedBtn" type="button">Overvalued</button>
        <button id="presetResetBtn" type="button">Reset</button>
      </div>
      <div class="op-toolbar">
        <div class="field">
          <label for="opView">View</label>
          <select id="opView">
            <option value="undervalued">Undervalued</option>
            <option value="deep_value">Deep Value</option>
            <option value="overvalued">Overvalued</option>
            <option value="all" selected>All (Full Universe)</option>
          </select>
        </div>
        <div class="field">
          <label for="minDiscount">Min Discount %</label>
          <input id="minDiscount" type="number" step="1" value="10" />
        </div>
        <div class="field">
          <label for="maxPeg">Max PEG</label>
          <input id="maxPeg" type="number" step="0.1" value="2.0" />
        </div>
        <div class="field">
          <label for="overvaluedThreshold">Overvalued Threshold %</label>
          <input id="overvaluedThreshold" type="number" step="1" value="-10" />
        </div>
        <div class="field">
          <label for="limitRows">Max Rows</label>
          <input id="limitRows" type="number" step="1" value="500" />
        </div>
        <div class="field">
          <label for="opSearch">Search Table</label>
          <input id="opSearch" type="text" placeholder="ticker, reason, etc" />
        </div>
        <button id="clearOpSearchBtn" type="button">Clear Search</button>
        <button id="loadOpBtn">Load</button>
      </div>
      <div id="opStatus" class="op-status"><span class="status-plain">Auto-loading full S&P500 table...</span></div>
      <div style="overflow-x: auto; max-width: 100%;"><table id="opTable"></table></div>
    </section>

    <section id="tabChart" class="hidden">
      <div class="panel">
        <div class="chart-toolbar">
          <input id="ticker" list="tickerList" value="SPY" placeholder="Ticker e.g. NVDA" />
          <datalist id="tickerList"></datalist>
          <label class="field" style="display:flex; flex-direction:row; align-items:center; gap:6px;">
            <input id="showTrendlines" type="checkbox" style="width:auto; padding:0; margin:0;" />
            <span style="font-size:0.8rem; color:var(--muted);">Show Trendlines</span>
          </label>
          <label class="field" style="display:flex; flex-direction:row; align-items:center; gap:6px;">
            <input id="showPatterns" type="checkbox" checked style="width:auto; padding:0; margin:0;" />
            <span style="font-size:0.8rem; color:var(--muted);">Show Patterns</span>
          </label>
          <label class="field" style="display:flex; flex-direction:row; align-items:center; gap:6px;">
            <input id="showRuleClassLines" type="checkbox" checked style="width:auto; padding:0; margin:0;" />
            <span style="font-size:0.8rem; color:var(--muted);">Rule/Hybrid Lines</span>
          </label>
          <label class="field" style="display:flex; flex-direction:row; align-items:center; gap:6px;">
            <input id="showCvClassLines" type="checkbox" checked style="width:auto; padding:0; margin:0;" />
            <span style="font-size:0.8rem; color:var(--muted);">CV Proxy Lines</span>
          </label>
          <label class="field" style="display:flex; flex-direction:row; align-items:center; gap:6px;">
            <input id="showYoloPatterns" type="checkbox" checked style="width:auto; padding:0; margin:0;" />
            <span style="font-size:0.8rem; color:var(--muted);">YOLO Patterns</span>
          </label>
          <div class="field" style="display:flex; flex-direction:row; align-items:center; gap:4px;">
            <span style="font-size:0.75rem; color:var(--muted);">Bars:</span>
            <button id="tfDailyBtn" style="padding:2px 9px; font-size:0.78rem; background:var(--blue); color:#fff; border:none; border-radius:3px; cursor:pointer;">D</button>
            <button id="tfWeeklyBtn" style="padding:2px 9px; font-size:0.78rem; background:var(--card); color:var(--muted); border:1px solid var(--border); border-radius:3px; cursor:pointer;">W</button>
          </div>
          <button id="loadChartBtn">Load</button>
          <div id="chartStatus" class="status">Select ticker and load</div>
        </div>
        <div class="mkt-bar">
          <span style="color:var(--muted); font-size:0.75rem;">Market:</span>
          <button onclick="loadTickerQuick('SPY')">SPY</button>
          <button onclick="loadTickerQuick('QQQ')">QQQ</button>
          <button onclick="loadTickerQuick('^VIX')">VIX</button>
          <button onclick="loadTickerQuick('SVIX')">SVIX</button>
          <button onclick="loadTickerQuick('^GSPC')">SPX</button>
          <button onclick="loadTickerQuick('^DJI')">DJI</button>
          <button onclick="loadTickerQuick('^TNX')">TNX</button>
        </div>

        <div class="cards">
          <div class="card"><div class="label">Price</div><div id="c-price" class="value">-</div></div>
          <div class="card"><div class="label">PE</div><div id="c-pe" class="value">-</div></div>
          <div class="card"><div class="label">PEG</div><div id="c-peg" class="value">-</div></div>
          <div class="card"><div class="label">Target</div><div id="c-target" class="value">-</div></div>
          <div class="card"><div class="label">Discount %</div><div id="c-discount" class="value">-</div></div>
          <div class="card"><div class="label">Put/Call OI</div><div id="c-pcr" class="value">-</div></div>
        </div>

        <div id="chart"></div>
      </div>

      <div class="table-wrap">
        <div class="panel">
          <div class="label">Levels</div>
          <table id="levelsTable"></table>
        </div>
        <div class="panel">
          <div class="label">Open Gaps</div>
          <table id="gapsTable"></table>
        </div>
        <div class="panel">
          <div class="label">Trendlines</div>
          <table id="trendlinesTable"></table>
        </div>
        <div class="panel">
          <div class="label">Pattern Candidates</div>
          <table id="patternsTable"></table>
        </div>
        <div class="panel">
          <div class="label">Hybrid Pattern Scores</div>
          <table id="hybridPatternsTable"></table>
        </div>
        <div class="panel">
          <div class="label">CV Proxy Pattern Scores</div>
          <table id="cvProxyPatternsTable"></table>
        </div>
        <div class="panel">
          <div class="label">Hybrid vs CV Compare</div>
          <table id="hybridCvCompareTable"></table>
        </div>
        <div class="panel">
          <div class="label">Pattern Overlays (Drawn)</div>
          <table id="patternOverlaysTable"></table>
        </div>
        <div class="panel">
          <div class="label">Candlestick Signals</div>
          <table id="candlesTable"></table>
        </div>
        <div class="panel">
          <div class="label">YOLO AI Patterns</div>
          <table id="yoloPatternsTable"></table>
        </div>
      </div>
    </section>

    <section id="tabReport" class="panel hidden">
      <div style="display:flex; align-items:center; gap:10px; margin-bottom:12px;">
        <h2 style="margin:0; font-size:1.1rem;">Daily Report</h2>
        <span id="reportStatus" style="font-size:0.8rem; color:var(--muted);"></span>
      </div>
      <div id="reportSummaryCards" class="cards" style="margin-bottom:14px;"></div>
      <div id="reportYoloCards" class="cards" style="margin-bottom:14px;"></div>

      <!-- 52W Extremes -->
      <div class="panel" style="margin-bottom:12px;">
        <div class="label" style="margin-bottom:8px;">52-Week Extremes (within 3% of high/low)</div>
        <div style="display:flex; gap:16px; flex-wrap:wrap;">
          <div style="flex:1; min-width:220px;">
            <div style="font-size:0.72rem; color:var(--green); font-weight:600; margin-bottom:6px; letter-spacing:.05em;">NEAR 52W HIGH</div>
            <div id="report52wHigh" style="font-size:0.82rem; line-height:1.7;"></div>
          </div>
          <div style="flex:1; min-width:220px;">
            <div style="font-size:0.72rem; color:var(--red); font-weight:600; margin-bottom:6px; letter-spacing:.05em;">NEAR 52W LOW</div>
            <div id="report52wLow" style="font-size:0.82rem; line-height:1.7;"></div>
          </div>
        </div>
      </div>

      <!-- Top YOLO patterns at close -->
      <div class="panel" style="margin-bottom:12px;">
        <div class="label" style="margin-bottom:8px;">Top AI Patterns at Close (YOLO)</div>
        <table id="reportYoloTopTable"></table>
      </div>

      <!-- Candle signals at close -->
      <div class="panel" style="margin-bottom:12px;">
        <div class="label" style="margin-bottom:8px;">Candle Signals at Close</div>
        <table id="reportCandleTable"></table>
      </div>

      <div class="panel" style="margin-bottom:12px;">
        <div class="label">Report History</div>
        <table id="reportHistoryTable"></table>
      </div>
      <div id="reportNoData" style="display:none; color:var(--muted); padding:20px 0;">
        No reports generated yet. Reports are written after the first daily cron run (22:00 UTC Mon–Fri).
      </div>
    </section>

    <section id="tabGuide" class="panel">
      <div class="guide">
        <div style="background:rgba(255,107,107,0.12); border:1px solid #ff6b6b; border-radius:10px; padding:12px 14px; margin-bottom:14px;">
          <div style="color:#ff8a8a; font-weight:700; font-size:0.95rem; margin-bottom:6px;">⚠ NOT FINANCIAL ADVICE</div>
          <p style="margin:0; color:var(--muted);">This tool is for research and education only. Nothing shown here constitutes financial advice, a recommendation to buy or sell, or a guarantee of any outcome. Signals can be wrong, delayed, or incomplete. You are solely responsible for your trades, risk management, and any financial losses. Always do your own research and consult a licensed financial adviser before making investment decisions.</p>
        </div>

        <h3>How to Use This Dashboard</h3>
        <p>This dashboard has four tabs: <b>Guide</b> (this page), <b>Opportunities (PEG)</b> for screening the S&amp;P 500 by valuation, <b>Chart + Levels</b> for per-ticker technical analysis, and <b>Daily Report</b> for an after-close summary of signals.</p>
        <p>Typical workflow: check the Daily Report tab each evening after the data refresh → use 52W extremes and pattern signals to build a watchlist → scan the Opportunities tab for valuation context → click a row to jump to that ticker's chart → study levels, gaps, and patterns to form a thesis.</p>

        <h3>Opportunities Tab — PEG &amp; Valuation Screening</h3>
        <p>The table shows all S&amp;P 500 tickers ranked by valuation. Key columns:</p>
        <p>• <b>Discount %</b>: how far the current price is below the analyst target (positive = upside, negative = already above target). E.g. <i>AAPL at 15% discount</i> means the average analyst target is 15% above the current price.</p>
        <p>• <b>PEG</b>: Price/Earnings-to-Growth ratio. A PEG below 1.0 is often considered "growth at a reasonable price". E.g. <i>PEG = 0.8 on a fast grower</i> is more attractive than <i>PEG = 3.0 on a slow grower</i>.</p>
        <p>• <b>Undervalued</b>: discount ≥ 10% AND PEG ≤ 2. <b>Deep Value</b>: stricter — discount ≥ 20% AND PEG ≤ 1.5. <b>Overvalued</b>: price is already above target by more than 10%.</p>
        <p>Click any row to open that ticker's chart automatically.</p>

        <h3>Support vs Resistance Levels</h3>
        <p><b>Support</b> is a price zone where buyers have previously stepped in, causing price to bounce up. <b>Resistance</b> is a zone where sellers have pushed price back down.</p>
        <p>Example: if SPY bounced off $450 three times in the past, $450 is strong support. If it has been rejected at $470 twice, $470 is resistance.</p>
        <p><b>Primary</b>: highest-confidence level (most recent touches, multiple hits). <b>Secondary</b>: next best level. <b>Fallback</b>: auto-generated anchor when no strong detected level exists on one side.</p>

        <h3>Open Gaps</h3>
        <p>A <b>bull gap</b> occurs when today's open is above yesterday's high — leaving an unfilled region below. A <b>bear gap</b> is the reverse. Markets often "fill" gaps later.</p>
        <p>Example: NVDA gaps up 5% on earnings — the gap low and high are marked. If price dips back to that range, it is testing the gap fill zone.</p>

        <h3>Trendlines</h3>
        <p>Heuristic best-fit lines drawn through recent swing pivots. A rising support trendline connecting higher lows suggests an uptrend. Toggle with the <i>Show Trendlines</i> checkbox.</p>
        <p>These are candidate lines only — not guaranteed to hold. Use them as context alongside levels.</p>

        <h3>Pattern Candidates (Rule-Based)</h3>
        <p>Geometric pattern detection (flags, wedges, triangles, double tops/bottoms) from recent price bars. Toggle with <i>Show Patterns</i>.</p>
        <p>Example: a <i>bull flag</i> is a sharp up-move followed by a tight, slightly downward channel — often resolves to the upside. A <i>head and shoulders</i> is a reversal pattern with three peaks, the middle being highest.</p>

        <h3>YOLO AI Patterns</h3>
        <p>A YOLOv8 computer-vision model (<a href="https://huggingface.co/foduucom/stockmarket-pattern-detection-yolov8" style="color:var(--blue);" target="_blank" rel="noopener">foduucom/stockmarket-pattern-detection-yolov8</a>) is run nightly on each ticker's candlestick chart image. Detected patterns are stored and shown as dotted bounding boxes on the chart.</p>
        <p>Pattern types: Head &amp; Shoulders Top/Bottom, M-Head, W-Bottom, Triangle, StockLine. Confidence is shown as a percentage — higher is more certain.</p>
        <p>Toggle with <i>YOLO Patterns</i> checkbox. These are updated each trading day and do not require any waiting on your end.</p>

        <h3>Hybrid Pattern Scores</h3>
        <p>Combines rule-based geometry confidence with candlestick alignment, volume regime, and breakout state into a single score. Higher hybrid confidence means more corroborating evidence.</p>

        <h3>CV Proxy Pattern Scores</h3>
        <p>An image-style shape scorer using normalised OHLC geometry — not a trained deep model, but useful as a secondary signal. Compare with Hybrid scores for consensus.</p>

        <h3>Daily Report Tab</h3>
        <p>Generated automatically after each daily data refresh (22:00 UTC Mon–Fri). The weekly YOLO pass runs separately on Saturdays and also triggers a report update. The report does not have a manual refresh button — it reflects the last completed cron run.</p>

        <p><b>52-Week Extremes</b> — lists every S&amp;P 500 ticker whose latest close is within 3% of its 52-week high or low. Click any ticker to jump directly to its chart.</p>
        <p>Rationale: proximity to a 52W high is a momentum signal — stocks making new highs are often in strong uptrends and may continue. Proximity to a 52W low flags potential capitulation or value traps. In both cases, the price is at a structurally significant level and worth further inspection.</p>
        <p>A ticker at its 52W high is not automatically bullish — check volume (a breakout on low volume is weak) and whether the high is a genuine new multi-year high or just a recovery within a longer downtrend. Similarly, a 52W low could be genuine distress or a brief oversold condition before recovery.</p>

        <p><b>Top AI Patterns at Close (YOLO)</b> — the 30 highest-confidence chart patterns detected by the YOLOv8 model on the latest trading day's data. Sorted by confidence. The <i>timeframe</i> column shows whether the detection came from the 180-day daily chart or the 730-day weekly chart.</p>
        <p>Rationale: rather than manually checking all 510 tickers, this surfaces the detections the model is most confident about. Patterns detected on the weekly timeframe represent larger, more structurally significant formations.</p>

        <p><b>Candle Signals at Close</b> — rule-based candlestick patterns detected on each ticker's latest closing candle. Common signals include engulfing candles, hammers, shooting stars, and three-candle reversal sequences (morning star, evening star, three white soldiers, three black crows).</p>
        <p>Rationale: candlestick signals are context-dependent — a hammer after a prolonged downtrend on high volume is far more meaningful than a hammer in the middle of a range. Use this list as a starting point to check the chart, not a standalone trade signal. Bullish and bearish signals are both shown; filter by <i>bias</i> to focus on one direction.</p>

        <h3>Display Window &amp; Chart Navigation</h3>
        <p>The <b>3M / 6M / YTD / 1Y / 2Y / ALL</b> buttons at the top-right of the chart change the view window. All data is always loaded — changing the window just zooms in. You can also drag to zoom, double-click to reset, and scroll to zoom.</p>
        <p>The engine uses a wider history window (up to all available data) for more stable level and pivot calculations, regardless of what is shown on screen.</p>

        <h3>Common Pitfalls</h3>
        <p>• <b>Pattern overfitting</b>: a pattern that worked in backtests may not work going forward.</p>
        <p>• <b>Survivorship bias</b>: S&amp;P 500 constituents are already winners — they have survived long enough to be listed here.</p>
        <p>• <b>Regime shifts</b>: patterns and levels from a bull market may not behave the same in a bear market or high-volatility regime.</p>
        <p>• <b>Low-liquidity distortions</b>: thin stocks can have false breakouts. Always check volume.</p>
        <p>Use strict position sizing and stop-losses. Never risk more than you can afford to lose.</p>

        <div style="margin-top:16px; padding:10px 14px; border-top:1px solid var(--line); color:var(--muted); font-size:0.82rem;">
          trader_koo is a personal research tool. All data is sourced from public market feeds and may be delayed or inaccurate. <b>Past performance is not indicative of future results.</b> This is NOT financial advice. Use at your own risk.
        </div>
      </div>
    </section>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);
    const tabOpBtn = $("tabOpBtn");
    const tabChartBtn = $("tabChartBtn");
    const tabGuideBtn = $("tabGuideBtn");
    const tabReportBtn = $("tabReportBtn");
    const tabOp = $("tabOp");
    const tabChart = $("tabChart");
    const tabGuide = $("tabGuide");
    const tabReport = $("tabReport");
    const API_BASE_STORAGE_KEY = "trader_koo_api_base";
    const TABLE_STATE = {};
    const DEFAULT_MONTHS = 3;
    let LAST_CHART_PAYLOAD = null;
    let CHART_TIMEFRAME = "daily"; // "daily" | "weekly"
    let _apiKey = "";

    function fmt(v, d = 2) {
      if (v === null || v === undefined || v === "" || Number.isNaN(Number(v))) return "-";
      return Number(v).toFixed(d);
    }

    function escHtml(v) {
      return String(v ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }

    const PERCENT_COLUMNS = new Set(["discount_pct", "eps_growth_5y", "atr_pct"]);
    const DECIMAL_BY_COLUMN = {
      price: 2,
      pe: 2,
      peg: 2,
      target_price: 2,
      discount_pct: 2,
      eps_growth_5y: 2,
      level: 2,
      zone_low: 2,
      zone_high: 2,
      gap_low: 2,
      gap_high: 2,
      score: 2,
      touches: 0,
      touch_count: 0,
      contracts: 0,
      call_oi: 0,
      put_oi: 0,
    };

    function formatTableValue(col, raw) {
      if (raw === null || raw === undefined || raw === "") return "-";
      if (typeof raw === "string" && /^\d{4}-\d{2}-\d{2}$/.test(raw)) return raw;
      const n = Number(raw);
      if (!Number.isFinite(n)) return String(raw);

      if (PERCENT_COLUMNS.has(col)) {
        let v = n;
        if (col === "eps_growth_5y" && Math.abs(v) <= 2) v *= 100;
        return `${v.toFixed(DECIMAL_BY_COLUMN[col] ?? 2)}%`;
      }

      const d = DECIMAL_BY_COLUMN[col] ?? 2;
      return n.toLocaleString(undefined, {
        minimumFractionDigits: d,
        maximumFractionDigits: d,
      });
    }

    function renderOpFilterHelp(help) {
      const el = $("opFilterHelp");
      if (!el) return;
      if (!help) {
        el.innerHTML = `<div class="op-help-title">Filter Guide</div><div class="status-plain">Use presets, then refine using the fields.</div>`;
        return;
      }
      const rows = [
        ["View", help.view],
        ["Min Discount %", help.min_discount],
        ["Max PEG", help.max_peg],
        ["Overvalued Threshold %", help.overvalued_threshold],
      ];
      el.innerHTML = `
        <div class="op-help-title">Filter Guide</div>
        <div class="op-help-grid">
          ${rows.map(([k, v]) => `<div class="op-help-key">${escHtml(k)}</div><div class="op-help-val">${escHtml(v)}</div>`).join("")}
        </div>
      `;
    }

    function renderOpStatus(payload, view, rowCount) {
      const el = $("opStatus");
      if (!el) return;
      const snapRaw = payload.snapshot_ts || "";
      const snapDate = snapRaw ? new Date(snapRaw) : null;
      const hasSnap = snapDate && !Number.isNaN(snapDate.getTime());
      const snapUtc = hasSnap
        ? snapDate.toISOString().slice(0, 16).replace("T", " ") + " UTC"
        : (snapRaw || "-");
      const snapLocal = hasSnap
        ? snapDate.toLocaleString(undefined, {
            year: "numeric",
            month: "short",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            hour12: false,
            timeZoneName: "short",
          })
        : "-";
      const sc = payload.source_counts || {};
      const chips = [
        ["Snapshot (UTC)", snapUtc],
        ["Local Time", snapLocal],
        ["View", view],
        ["Shown", rowCount ?? 0],
        ["Eligible", payload.eligible_count ?? "-"],
        ["Universe", payload.universe_count ?? "-"],
        ["Analyst", sc.analyst_target ?? 0],
        ["Model", sc.model_eps_pe ?? 0],
        ["Other", sc.other ?? 0],
      ];
      el.innerHTML = chips
        .map(([k, v]) => `<span class="status-chip"><span class="k">${escHtml(k)}</span><span class="v">${escHtml(v)}</span></span>`)
        .join("");
    }

    function normalizeBase(base) {
      return String(base || "").trim().replace(/\/+$/, "");
    }

    function getApiBase() {
      return normalizeBase($("apiBase").value);
    }

    function apiFetch(url, opts = {}) {
      const headers = { ...(opts.headers || {}) };
      if (_apiKey) headers["X-API-Key"] = _apiKey;
      return fetch(url, { ...opts, headers });
    }

    async function initApiKey() {
      const base = getApiBase();
      try {
        const resp = await fetch(`${base}/api/config`);
        if (resp.ok) { const cfg = await resp.json(); _apiKey = cfg.api_key || ""; }
      } catch { /* no-op */ }
    }

    function setApiBase(base, persist = true) {
      const clean = normalizeBase(base);
      $("apiBase").value = clean;
      if (persist && clean) localStorage.setItem(API_BASE_STORAGE_KEY, clean);
    }

    function buildApiCandidates() {
      const params = new URLSearchParams(window.location.search);
      const fromQuery = normalizeBase(params.get("api"));
      const fromStorage = normalizeBase(localStorage.getItem(API_BASE_STORAGE_KEY));
      const fromInput = normalizeBase($("apiBase").value);
      const isHttp = window.location.protocol === "http:" || window.location.protocol === "https:";
      const sameOrigin = isHttp ? normalizeBase(window.location.origin) : "";
      const host = window.location.hostname || "127.0.0.1";
      const host8000 = `http://${host}:8000`;
      const defaults = ["http://127.0.0.1:8000", "http://localhost:8000"];
      const candidates = [fromInput, fromQuery, fromStorage, sameOrigin, host8000, ...defaults].filter(Boolean);
      return [...new Set(candidates)];
    }

    async function probeApi(base, timeoutMs = 1200) {
      try {
        const controller = new AbortController();
        const timer = setTimeout(() => controller.abort(), timeoutMs);
        const resp = await fetch(`${base}/api/health`, { signal: controller.signal });
        clearTimeout(timer);
        return resp.ok;
      } catch {
        return false;
      }
    }

    async function initApiBase() {
      const candidates = buildApiCandidates();
      for (const c of candidates) {
        if (await probeApi(c)) {
          setApiBase(c, true);
          return;
        }
      }
      setApiBase(candidates[0] || "http://127.0.0.1:8000", true);
    }

    function setGlobalStatus(s) { $("globalStatus").textContent = s; }
    function setServiceStatus(s, bad = false) {
      const el = $("serviceStatus");
      el.textContent = s;
      el.style.color = bad ? "#ff8a8a" : "#8ea0bd";
    }

    async function refreshServiceStatus() {
      const base = getApiBase();
      if (!base) {
        setServiceStatus("Service status: missing API base", true);
        return;
      }
      try {
        const resp = await apiFetch(`${base}/api/status`);
        if (!resp.ok) throw new Error(`${resp.status}`);
        const payload = await resp.json();
        const run = payload.latest_run || {};
        const txt = [
          `API ${payload.ok ? "UP" : "STALE"}`,
          `run=${run.status || "n/a"}`,
          `tickers=${payload.counts?.tracked_tickers ?? "-"}`,
          `price_age=${payload.freshness?.price_age_days ?? "-"}d`
        ].join(" • ");
        setServiceStatus(txt, !payload.ok);
      } catch (err) {
        setServiceStatus(`API DOWN (${err.message})`, true);
      }
    }

    async function triggerUpdate() {
      const base = getApiBase();
      if (!base) { alert("API base not resolved yet."); return; }
      const btn = $("triggerUpdateBtn");
      btn.disabled = true;
      btn.textContent = "Triggering...";
      try {
        const resp = await apiFetch(`${base}/api/admin/trigger-update`, { method: "POST" });
        if (!resp.ok) throw new Error(`${resp.status} ${await resp.text()}`);
        btn.textContent = "Triggered ✓";
        setTimeout(() => { btn.textContent = "Run Update"; btn.disabled = false; }, 5000);
      } catch (err) {
        alert(`Failed: ${err.message}`);
        btn.textContent = "Run Update";
        btn.disabled = false;
      }
    }

    function activateTab(which) {
      const all = { op: [tabOpBtn, tabOp], chart: [tabChartBtn, tabChart], guide: [tabGuideBtn, tabGuide], report: [tabReportBtn, tabReport] };
      for (const [k, [btn, sec]] of Object.entries(all)) {
        if (k === which) { btn.classList.add("active"); sec.classList.remove("hidden"); }
        else             { btn.classList.remove("active"); sec.classList.add("hidden"); }
      }
      if (which === "report") loadReport();
    }

    tabOpBtn.addEventListener("click", () => activateTab("op"));
    tabChartBtn.addEventListener("click", () => activateTab("chart"));
    tabGuideBtn.addEventListener("click", () => activateTab("guide"));
    tabReportBtn.addEventListener("click", () => activateTab("report"));

    function fillCards(payload) {
      const f = payload.fundamentals || {};
      const o = payload.options_summary || {};
      $("c-price").textContent = fmt(f.price);
      $("c-pe").textContent = fmt(f.pe);
      $("c-peg").textContent = fmt(f.peg);
      $("c-target").textContent = fmt(f.target_price);
      $("c-discount").textContent = fmt(f.discount_pct);
      $("c-pcr").textContent = fmt(o.put_call_oi_ratio, 3);
    }

    function renderSimpleTable(elId, columns, rows, clickable = false, onClick = null, opts = {}) {
      const state = TABLE_STATE[elId] || { sortCol: null, sortAsc: false };
      TABLE_STATE[elId] = state;
      const el = $(elId);
      let viewRows = [...rows];
      const searchId = opts.searchInputId || "";
      if (searchId && $(searchId)) {
        const q = String($(searchId).value || "").trim().toLowerCase();
        if (q) {
          viewRows = viewRows.filter((r) =>
            columns.some((c) => String(r[c] ?? "").toLowerCase().includes(q))
          );
        }
      }

      if (opts.sortable && state.sortCol) {
        const col = state.sortCol;
        const dir = state.sortAsc ? 1 : -1;
        viewRows.sort((a, b) => {
          const av = a[col], bv = b[col];
          const an = Number(av), bn = Number(bv);
          if (Number.isFinite(an) && Number.isFinite(bn)) return (an - bn) * dir;
          return String(av ?? "").localeCompare(String(bv ?? "")) * dir;
        });
      }

      const head = `<tr>${columns.map((c) => {
        if (!opts.sortable) return `<th>${c}</th>`;
        const marker = state.sortCol === c ? (state.sortAsc ? " ▲" : " ▼") : "";
        return `<th data-sort-col="${c}" style="cursor:pointer;">${c}${marker}</th>`;
      }).join("")}</tr>`;

      const body = viewRows.length
        ? viewRows.map((r, idx) => {
            const cls = clickable ? "clickable" : "";
            return `<tr class="${cls}" data-idx="${idx}">${columns.map(c => `<td>${formatTableValue(c, r[c])}</td>`).join("")}</tr>`;
          }).join("")
        : `<tr><td colspan="${columns.length}">No data</td></tr>`;
      el.innerHTML = head + body;

      if (opts.sortable) {
        el.querySelectorAll("th[data-sort-col]").forEach((th) => {
          th.addEventListener("click", () => {
            const c = th.getAttribute("data-sort-col");
            if (!c) return;
            if (state.sortCol === c) state.sortAsc = !state.sortAsc;
            else {
              state.sortCol = c;
              state.sortAsc = true;
            }
            renderSimpleTable(elId, columns, rows, clickable, onClick, opts);
          });
        });
      }

      if (searchId && $(searchId)) {
        $(searchId).oninput = () => renderSimpleTable(elId, columns, rows, clickable, onClick, opts);
      }

      if (clickable && onClick) {
        el.querySelectorAll("tr.clickable").forEach((tr) => {
          tr.addEventListener("click", () => {
            const idx = Number(tr.getAttribute("data-idx"));
            onClick(viewRows[idx]);
          });
        });
      }
    }

    function computeYRangeForXWindow(x, low, high, x0, x1) {
      if (!x.length) return null;
      const t0 = x0 ? new Date(x0).getTime() : -Infinity;
      const t1 = x1 ? new Date(x1).getTime() : Infinity;
      let minY = Number.POSITIVE_INFINITY;
      let maxY = Number.NEGATIVE_INFINITY;
      for (let i = 0; i < x.length; i++) {
        const t = new Date(x[i]).getTime();
        if (Number.isNaN(t) || t < t0 || t > t1) continue;
        const lo = Number(low[i]);
        const hi = Number(high[i]);
        if (Number.isFinite(lo)) minY = Math.min(minY, lo);
        if (Number.isFinite(hi)) maxY = Math.max(maxY, hi);
      }
      if (!Number.isFinite(minY) || !Number.isFinite(maxY)) {
        const allLow = low.filter(Number.isFinite);
        const allHigh = high.filter(Number.isFinite);
        if (!allLow.length || !allHigh.length) return null;
        minY = Math.min(...allLow);
        maxY = Math.max(...allHigh);
      }
      const span = Math.max(maxY - minY, Math.abs(maxY) * 0.01, 1e-6);
      const pad = span * 0.08;
      return [minY - pad, maxY + pad];
    }

    function extendYRangeWithLevelValues(range, levelValues) {
      if (!range || !Array.isArray(range) || range.length !== 2) return range;
      const baseLo = Number(range[0]);
      const baseHi = Number(range[1]);
      if (!Number.isFinite(baseLo) || !Number.isFinite(baseHi)) return range;
      const span = Math.max(baseHi - baseLo, Math.abs(baseHi) * 0.01, 1e-6);
      const nearLo = baseLo - span * 0.35;
      const nearHi = baseHi + span * 0.35;

      let lo = baseLo;
      let hi = baseHi;
      for (const vRaw of (levelValues || [])) {
        const v = Number(vRaw);
        if (!Number.isFinite(v)) continue;
        if (v < nearLo || v > nearHi) continue;
        lo = Math.min(lo, v);
        hi = Math.max(hi, v);
      }
      const newSpan = Math.max(hi - lo, Math.abs(hi) * 0.01, 1e-6);
      const pad = newSpan * 0.08;
      return [lo - pad, hi + pad];
    }

    function resampleToWeekly(chart) {
      // ISO week key → use last trading day of that week as the bar date
      const isoWeek = (ds) => {
        const d = new Date(ds + "T12:00:00Z");
        const day = d.getUTCDay() || 7;
        d.setUTCDate(d.getUTCDate() + 4 - day); // Thursday anchor
        const yr = d.getUTCFullYear();
        const jan4 = new Date(Date.UTC(yr, 0, 4));
        const wk = Math.ceil(((d - jan4) / 864e5 + (jan4.getUTCDay() || 7)) / 7);
        return `${yr}-${String(wk).padStart(2, "0")}`;
      };
      const weeks = new Map();
      for (const row of chart) {
        const key = isoWeek(row.date);
        if (!weeks.has(key)) {
          weeks.set(key, { date: row.date, open: Number(row.open), high: Number(row.high), low: Number(row.low), close: Number(row.close), volume: Number(row.volume) || 0 });
        } else {
          const w = weeks.get(key);
          w.high = Math.max(w.high, Number(row.high));
          w.low  = Math.min(w.low,  Number(row.low));
          w.close = Number(row.close);
          w.date  = row.date; // last trading day of the week
          w.volume += Number(row.volume) || 0;
        }
      }
      return Array.from(weeks.values());
    }

    function renderChart(payload) {
      LAST_CHART_PAYLOAD = payload;
      const isWeeklyChart = CHART_TIMEFRAME === "weekly";
      const rawChart = payload.chart || [];
      const chart = isWeeklyChart ? resampleToWeekly(rawChart) : rawChart;
      const levels = payload.levels || [];
      const gaps = payload.gaps || [];
      const trendlines = payload.trendlines || [];
      const patterns = payload.patterns || [];
      const patternOverlays = payload.pattern_overlays || [];
      const yoloPatterns = payload.yolo_patterns || [];
      const ticker = payload.ticker || "N/A";
      const showTrendlines = $("showTrendlines") ? Boolean($("showTrendlines").checked) : false;
      const showPatterns = $("showPatterns") ? Boolean($("showPatterns").checked) : true;
      const showRuleClassLines = $("showRuleClassLines") ? Boolean($("showRuleClassLines").checked) : true;
      const showCvClassLines = $("showCvClassLines") ? Boolean($("showCvClassLines").checked) : true;
      const showYoloPatterns = $("showYoloPatterns") ? Boolean($("showYoloPatterns").checked) : true;

      const x = chart.map(r => r.date);
      const open = chart.map(r => Number(r.open));
      const high = chart.map(r => Number(r.high));
      const low = chart.map(r => Number(r.low));
      const close = chart.map(r => Number(r.close));
      const vol = chart.map(r => Number(r.volume || 0));
      const volColor = chart.map(r => Number(r.close) >= Number(r.open) ? "rgba(56,211,159,0.7)" : "rgba(255,107,107,0.7)");

      const ma = (arr, n) => arr.map((_, i) => {
        if (i < n - 1) return null;
        let s = 0;
        for (let j = i - n + 1; j <= i; j++) s += arr[j];
        return s / n;
      });

      const traces = [
        {
          type: "candlestick",
          x, open, high, low, close,
          name: ticker, xaxis: "x", yaxis: "y",
          increasing: {line: {color: "#38d39f"}, fillcolor: "rgba(56,211,159,0.85)"},
          decreasing: {line: {color: "#ff6b6b"}, fillcolor: "rgba(255,107,107,0.85)"}
        },
        { type: "scatter", mode: "lines", x, y: ma(close, 20), name: "MA20", line: {color:"#6aa9ff", width:1.2}, xaxis:"x", yaxis:"y" },
        { type: "scatter", mode: "lines", x, y: ma(close, 50), name: "MA50", line: {color:"#f8c24e", width:1.2}, xaxis:"x", yaxis:"y" },
        { type: "scatter", mode: "lines", x, y: ma(close, 100), name: "MA100", line: {color:"#38d39f", width:1.2}, xaxis:"x", yaxis:"y" },
        { type: "scatter", mode: "lines", x, y: ma(close, 200), name: "MA200", line: {color:"#c07bff", width:1.2}, xaxis:"x", yaxis:"y" },
        { type: "bar", x, y: vol, name: "Volume", marker: {color: volColor}, xaxis:"x2", yaxis:"y2" }
      ];

      const candlePatterns = payload.candlestick_patterns || [];
      if (candlePatterns.length > 0) {
        const bullish = candlePatterns.filter(p => String(p.bias || "").toLowerCase() === "bullish");
        const bearish = candlePatterns.filter(p => String(p.bias || "").toLowerCase() === "bearish");
        if (bullish.length > 0) {
          traces.push({
            type: "scatter", mode: "markers",
            x: bullish.map(p => p.date),
            y: bullish.map(p => { const i = x.indexOf(p.date); return i >= 0 ? low[i] * 0.994 : null; }),
            name: "Bullish Signal",
            marker: {symbol: "triangle-up", size: 9, color: "#38d39f"},
            hovertext: bullish.map(p => `${p.pattern} (${fmt(p.confidence)})`),
            hoverinfo: "text+x", xaxis: "x", yaxis: "y"
          });
        }
        if (bearish.length > 0) {
          traces.push({
            type: "scatter", mode: "markers",
            x: bearish.map(p => p.date),
            y: bearish.map(p => { const i = x.indexOf(p.date); return i >= 0 ? high[i] * 1.006 : null; }),
            name: "Bearish Signal",
            marker: {symbol: "triangle-down", size: 9, color: "#ff6b6b"},
            hovertext: bearish.map(p => `${p.pattern} (${fmt(p.confidence)})`),
            hoverinfo: "text+x", xaxis: "x", yaxis: "y"
          });
        }
      }

      const lastDate = x.length ? x[x.length - 1] : null;
      const selectedMonths = DEFAULT_MONTHS; // default view window; use rangeselector to zoom
      const defaultX0 = (() => {
        if (!lastDate) return null;
        if (selectedMonths <= 0) return x.length ? x[0] : null;
        const d = new Date(lastDate);
        d.setMonth(d.getMonth() - selectedMonths);
        return d.toISOString().slice(0, 10);
      })();
      const defaultX1 = lastDate || null;
      const levelValues = levels.map((r) => Number(r.level)).filter(Number.isFinite);
      const baseDefaultY = computeYRangeForXWindow(x, low, high, defaultX0, defaultX1);
      const defaultY = extendYRangeWithLevelValues(baseDefaultY, levelValues);

      const isMobile = window.innerWidth < 640;
      const shapes = [];
      const annotations = [];

      levels.forEach(r => {
        const lvl = Number(r.level);
        if (Number.isNaN(lvl)) return;
        const color = r.type === "support" ? "#3f8cff" : "#ff7b5b";
        const tier = (r.tier || "primary").toLowerCase();
        const dash = tier === "primary" ? "solid" : (tier === "secondary" ? "dot" : "dash");
        const width = tier === "primary" ? 2 : (tier === "secondary" ? 1 : 1.5);
        const tierLabel = tier === "primary" ? "PRIMARY" : (tier === "secondary" ? "SECONDARY" : "FALLBACK");
        const z0 = Number(r.zone_low);
        const z1 = Number(r.zone_high);
        if (!Number.isNaN(z0) && !Number.isNaN(z1)) {
          shapes.push({
            type: "rect", xref: "paper", yref: "y",
            x0: 0, x1: 1, y0: Math.min(z0, z1), y1: Math.max(z0, z1),
            fillcolor: r.type === "support" ? "rgba(63,140,255,0.10)" : "rgba(255,123,91,0.10)",
            line: {width: 0}
          });
        }
        shapes.push({
          type: "line", xref: "paper", yref: "y",
          x0: 0, x1: 1, y0: lvl, y1: lvl,
          line: {color, width, dash}
        });
        annotations.push({
          xref: "paper", yref: "y", x: 1.0, y: lvl,
          text: isMobile
            ? fmt(lvl)
            : `${tierLabel} ${String(r.type).toUpperCase()}<br>${fmt(lvl)} (${r.touches ?? "-"})`,
          showarrow: false, xanchor: "left", yanchor: "middle", align: "left",
          xshift: 4, borderpad: 2,
          bgcolor: "rgba(18,25,39,0.9)", bordercolor: color,
          font: {color, size: isMobile ? 10 : 11}
        });
      });

      gaps.forEach(g => {
        const y0 = Number(g.gap_low), y1 = Number(g.gap_high);
        if (Number.isNaN(y0) || Number.isNaN(y1)) return;
        shapes.push({
          type: "rect", xref: "x", yref: "y",
          x0: g.date, x1: x[x.length - 1], y0, y1,
          fillcolor: g.type === "bull_gap" ? "rgba(248,194,78,0.22)" : "rgba(106,169,255,0.20)",
          line: {width: 1, color: "rgba(142,160,189,0.6)"}
        });
      });

      if (showTrendlines) trendlines.forEach(t => {
        const y0 = Number(t.y0);
        const y1 = Number(t.y1);
        if (Number.isNaN(y0) || Number.isNaN(y1)) return;
        const color = String(t.type || "").includes("support") ? "#38d39f" : "#ff6b6b";
        shapes.push({
          type: "line",
          xref: "x",
          yref: "y",
          x0: t.x0_date,
          x1: t.x1_date,
          y0,
          y1,
          line: {color, width: 1.6, dash: "dot"}
        });
      });

      if (showPatterns) {
        const patternColor = (nameRaw) => {
          const name = String(nameRaw || "").toLowerCase();
          if (
            name.includes("bull")
            || name.includes("falling_wedge")
            || name.includes("ascending_triangle")
            || name.includes("double_bottom")
            || name.includes("inv_head")
          ) return "#38d39f";
          if (
            name.includes("bear")
            || name.includes("rising_wedge")
            || name.includes("descending_triangle")
            || name.includes("double_top")
            || name.includes("head_and_shoulders")
          ) return "#ff6b6b";
          return "#f8c24e";
        };
        const sourceDash = (sRaw) => {
          const s = String(sRaw || "").toLowerCase();
          if (s === "cv_proxy") return "dashdot";
          if (s === "hybrid_rule") return "solid";
          return "dot";
        };

        let overlays = patternOverlays.filter((p) => {
          const src = String(p.source || "");
          if (!showRuleClassLines && (src === "rule" || src === "hybrid_rule")) return false;
          if (!showCvClassLines && src === "cv_proxy") return false;
          return true;
        });

        if (!overlays.length) {
          overlays = patterns.slice(0, 4).map((p) => ({
            source: "rule",
            class_name: p.pattern,
            status: p.status,
            confidence: p.confidence,
            x0_date: p.x0_date,
            x1_date: p.x1_date,
            y0: p.y0,
            y1: p.y1,
            y0b: p.y0b,
            y1b: p.y1b,
            notes: p.notes,
          }));
        }

        overlays = overlays
          .slice()
          .sort((a, b) => Number(b.confidence || 0) - Number(a.confidence || 0))
          .slice(0, 10);

        overlays.forEach((p, idx) => {
          const y0 = Number(p.y0);
          const y1 = Number(p.y1);
          const y0b = Number(p.y0b);
          const y1b = Number(p.y1b);
          if ([y0, y1, y0b, y1b].some(Number.isNaN)) return;
          const className = String(p.class_name || p.pattern || "pattern");
          const status = String(p.status || "forming");
          const source = String(p.source || "rule");
          const conf = Number(p.confidence);
          const color = patternColor(className);
          const dash = sourceDash(source);
          const width = source === "hybrid_rule" ? 2.1 : 1.7;
          const shortSrc = source === "hybrid_rule" ? "HYB" : (source === "cv_proxy" ? "CV" : "RULE");

          shapes.push({
            type: "line",
            xref: "x",
            yref: "y",
            x0: p.x0_date,
            x1: p.x1_date,
            y0,
            y1,
            line: {color, width, dash},
          });
          shapes.push({
            type: "line",
            xref: "x",
            yref: "y",
            x0: p.x0_date,
            x1: p.x1_date,
            y0: y0b,
            y1: y1b,
            line: {color, width, dash},
          });
          if (!isMobile) {
            annotations.push({
              xref: "paper",
              yref: "paper",
              x: 0.01,
              y: 0.98 - idx * 0.045,
              text: `${className.replaceAll("_", " ")} • ${shortSrc} • ${status} • ${fmt(conf, 2)}`,
              showarrow: false,
              xanchor: "left",
              yanchor: "top",
              bgcolor: "rgba(18,25,39,0.85)",
              bordercolor: color,
              font: {color, size: 11},
            });
          }
        });
      }

      if (showYoloPatterns && yoloPatterns.length > 0) {
        const yoloColorMap = {
          bull: {stroke: "#38d39f", fill: "rgba(56,211,159,0.07)"},
          bear: {stroke: "#ff6b6b", fill: "rgba(255,107,107,0.07)"},
          neutral: {stroke: "#f8c24e", fill: "rgba(248,194,78,0.07)"},
        };
        const yoloLabel = (nameRaw, compact = false) => {
          const raw = String(nameRaw || "").replaceAll("_", " ").trim();
          const map = {
            "Head and shoulders bottom": "H&S Bottom",
            "Head and shoulders top": "H&S Top",
            "M Head": "M Head",
            "W Bottom": "W Bottom",
            "StockLine": "Stock Line",
          };
          let label = map[raw] || raw || "Pattern";
          if (compact) {
            const compactMap = {
              "H&S Bottom": "H&S Bot",
              "H&S Top":    "H&S Top",
              "W Bottom":   "W Bot",
              "M Head":     "M Head",
              "Stock Line": "StkLine",
              "Triangle":   "Triangle",
            };
            label = compactMap[label] ?? (label.length > 10 ? `${label.slice(0, 10)}…` : label);
          }
          return label;
        };
        const yoloStyle = (nameRaw) => {
          const n = String(nameRaw || "").toLowerCase();
          if (n.includes("bottom") || n.includes("w_bottom") || n.includes("shoulders bottom")) return yoloColorMap.bull;
          if (n.includes("top") || n.includes("m_head") || n.includes("shoulders top")) return yoloColorMap.bear;
          return yoloColorMap.neutral;
        };
        // Separate daily vs weekly so weekly renders with a wider, dashed border
        const dailyPatterns = yoloPatterns.filter(p => (p.timeframe || "daily") === "daily");
        const weeklyPatterns = yoloPatterns.filter(p => p.timeframe === "weekly");

        const renderYoloGroup = (group, isWeekly) => {
          const borderWidth = isWeekly ? 2.2 : 1.5;
          const borderDash = isWeekly ? "dash" : "dot";
          const fillOpacity = isWeekly ? "0.05" : "0.07";
          const maxLabels = isMobile ? (isWeekly ? 2 : 3) : 5;
          let labelCount = 0;
          group.forEach((p) => {
            const y0 = Number(p.y0), y1 = Number(p.y1);
            if (Number.isNaN(y0) || Number.isNaN(y1)) return;
            const baseStyle = yoloStyle(p.pattern);
            // Weekly uses slightly muted colours to not compete with daily boxes
            const stroke = isWeekly ? baseStyle.stroke + "cc" : baseStyle.stroke;
            const fill = baseStyle.fill.replace(/[\d.]+\)$/, `${fillOpacity})`);
            const conf = Number(p.confidence);
            const label = isWeekly ? "W" : "D";
            shapes.push({
              type: "rect",
              xref: "x",
              yref: "y",
              x0: p.x0_date,
              x1: p.x1_date,
              y0: Math.min(y0, y1),
              y1: Math.max(y0, y1),
              line: {color: stroke, width: borderWidth, dash: borderDash},
              fillcolor: fill,
            });
            if (labelCount < maxLabels) {
              const confPct = Number.isFinite(conf) ? `${(conf * 100).toFixed(0)}%` : "";
              const labelName = yoloLabel(p.pattern, isMobile);
              const text = isMobile
                ? `${label}:${labelName} ${confPct}`
                : `[${label}] ${yoloLabel(p.pattern, false)} ${confPct}`;
              const yTop = Math.max(y0, y1);
              annotations.push({
                xref: "x",
                yref: "y",
                x: isMobile ? p.x0_date : p.x1_date,
                y: yTop,
                text,
                showarrow: false,
                xanchor: "left",
                yanchor: isMobile ? "top" : "bottom",
                xshift: isMobile ? 2 : 4,
                yshift: isMobile ? -2 : 0,
                bgcolor: "rgba(18,25,39,0.85)",
                bordercolor: baseStyle.stroke,
                font: {color: baseStyle.stroke, size: isMobile ? 8 : (isWeekly ? 9 : 10)},
              });
              labelCount++;
            }
          });
        };

        renderYoloGroup(dailyPatterns, false);
        renderYoloGroup(weeklyPatterns, true);
      }

      const layout = {
        paper_bgcolor: "#121927",
        plot_bgcolor: "#121927",
        font: {color: "#e9eef8"},
        margin: isMobile ? {t: 40, l: 45, r: 80, b: 40} : {t: 40, l: 60, r: 235, b: 50},
        dragmode: "zoom",
        legend: isMobile
          ? {orientation: "h", y: -0.08, x: 0, xanchor: "left", font: {size: 10}}
          : {orientation: "h", y: -0.04, x: 0, xanchor: "left"},
        xaxis: {
          domain: [0, 1], anchor: "y", rangeslider: {visible: false},
          showgrid: true, gridcolor: "#25334f",
          range: defaultX0 && defaultX1 ? [defaultX0, defaultX1] : undefined,
          rangebreaks: [{bounds: ["sat", "mon"]}],
          rangeselector: {
            bgcolor: "#e9eef8",
            activecolor: "#6aa9ff",
            bordercolor: "#0b0f16",
            borderwidth: 1,
            font: {color: "#0b0f16", size: 12},
            buttons: [
              {count: 3, step: "month", stepmode: "backward", label: "3M"},
              {count: 6, step: "month", stepmode: "backward", label: "6M"},
              {count: 1, step: "year", stepmode: "todate", label: "YTD"},
              {count: 1, step: "year", stepmode: "backward", label: "1Y"},
              {count: 2, step: "year", stepmode: "backward", label: "2Y"},
              {step: "all", label: "ALL"}
            ]
          }
        },
        yaxis: {
          domain: [0.30, 1],
          showgrid: true,
          gridcolor: "#25334f",
          title: "Price",
          range: defaultY || undefined,
          autorange: !defaultY
        },
        xaxis2: {domain: [0, 1], anchor: "y2", matches: "x", showgrid: false},
        yaxis2: {domain: [0, 0.24], showgrid: true, gridcolor: "#25334f", title: "Volume"},
        shapes,
        annotations
      };

      Plotly.newPlot("chart", traces, layout, {responsive: true, scrollZoom: true, displayModeBar: true});
      const chartEl = $("chart");
      let ySyncLock = false;
      chartEl.on("plotly_relayout", (ev) => {
        if (ySyncLock) return;
        const hasXRange = "xaxis.range[0]" in ev || Array.isArray(ev["xaxis.range"]);
        const allX = ev["xaxis.autorange"] === true;
        if (!hasXRange && !allX) return; // ignore Y-only or unrelated events — prevents snap-back
        const r0 = ev["xaxis.range[0]"] ?? (Array.isArray(ev["xaxis.range"]) ? ev["xaxis.range"][0] : null);
        const r1 = ev["xaxis.range[1]"] ?? (Array.isArray(ev["xaxis.range"]) ? ev["xaxis.range"][1] : null);
        const baseYr = allX
          ? computeYRangeForXWindow(x, low, high, x[0], x[x.length - 1])
          : computeYRangeForXWindow(x, low, high, r0 || x[0], r1 || x[x.length - 1]);
        const yr = extendYRangeWithLevelValues(baseYr, levelValues);
        if (!yr) return;
        ySyncLock = true;
        Plotly.relayout("chart", {"yaxis.range": yr})
          .catch(() => {})
          .finally(() => { ySyncLock = false; });
      });
    }

    function setOpportunityFilters({view, minDiscount, maxPeg, overvaluedThreshold, limitRows}) {
      if (view !== undefined) $("opView").value = String(view);
      if (minDiscount !== undefined) $("minDiscount").value = String(minDiscount);
      if (maxPeg !== undefined) $("maxPeg").value = String(maxPeg);
      if (overvaluedThreshold !== undefined) $("overvaluedThreshold").value = String(overvaluedThreshold);
      if (limitRows !== undefined) $("limitRows").value = String(limitRows);
    }

    function applyOpportunityPreset(name) {
      if ($("opSearch")) $("opSearch").value = "";
      if (name === "all") {
        setOpportunityFilters({ view: "all", minDiscount: 10, maxPeg: 2.0, overvaluedThreshold: -10, limitRows: 500 });
      } else if (name === "undervalued") {
        setOpportunityFilters({ view: "undervalued", minDiscount: 10, maxPeg: 2.0, overvaluedThreshold: -10, limitRows: 500 });
      } else if (name === "deep_value") {
        setOpportunityFilters({ view: "deep_value", minDiscount: 20, maxPeg: 1.5, overvaluedThreshold: -10, limitRows: 500 });
      } else if (name === "overvalued") {
        setOpportunityFilters({ view: "overvalued", minDiscount: 10, maxPeg: 2.0, overvaluedThreshold: -10, limitRows: 500 });
      } else {
        setOpportunityFilters({ view: "all", minDiscount: 10, maxPeg: 2.0, overvaluedThreshold: -10, limitRows: 500 });
      }
      loadOpportunities();
    }

    async function loadOpportunities() {
      const base = getApiBase();
      const view = String($("opView").value || "all");
      const apiView = view === "deep_value" ? "undervalued" : view;
      const minDiscount = Number($("minDiscount").value || 10);
      const maxPeg = Number($("maxPeg").value || 2);
      const overvaluedThreshold = Number($("overvaluedThreshold").value || -10);
      const limitRows = Number($("limitRows").value || 500);
      const btn = $("loadOpBtn");
      btn.disabled = true;
      $("opStatus").innerHTML = `<span class="status-plain">Loading opportunities...</span>`;
      setGlobalStatus("Loading opportunities...");
      try {
        const q = new URLSearchParams({
          limit: String(limitRows),
          min_discount: String(minDiscount),
          max_peg: String(maxPeg),
          overvalued_threshold: String(overvaluedThreshold),
          view: apiView,
        });
        const resp = await apiFetch(`${base}/api/opportunities?${q.toString()}`);
        if (!resp.ok) throw new Error(`${resp.status} ${await resp.text()}`);
        const payload = await resp.json();
        const rows = payload.rows || [];
        renderOpFilterHelp(payload.filter_help || null);
        renderSimpleTable(
          "opTable",
          ["ticker", "price", "pe", "peg", "target_price", "discount_pct", "valuation_label", "eps_growth_5y"],
          rows,
          true,
          (row) => {
            $("ticker").value = row.ticker;
            activateTab("chart");
            loadChart();
          },
          { sortable: true, searchInputId: "opSearch" }
        );
        renderOpStatus(payload, view, rows.length);
        setGlobalStatus("Opportunities loaded");
      } catch (err) {
        console.error(err);
        $("opStatus").innerHTML = `<span class="status-plain" style="color:#ff8a8a;">Failed: ${escHtml(err.message)}</span>`;
        setGlobalStatus("Failed loading opportunities");
      } finally {
        btn.disabled = false;
      }
    }

    async function loadChart() {
      const ticker = ($("ticker").value || "SPY").trim().toUpperCase();
      const months = 0; // always fetch all data; view window controlled by rangeselector
      const base = getApiBase();
      const btn = $("loadChartBtn");
      btn.disabled = true;
      $("chartStatus").textContent = `Loading ${ticker}...`;
      setGlobalStatus(`Loading ${ticker} dashboard...`);
      try {
        const resp = await apiFetch(`${base}/api/dashboard/${ticker}?months=${months}`);
        if (!resp.ok) throw new Error(`${resp.status} ${await resp.text()}`);
        const payload = await resp.json();
        fillCards(payload);
        renderChart(payload);
        renderSimpleTable("levelsTable", ["type", "level", "zone_low", "zone_high", "tier", "touches", "last_touch_date"], payload.levels || [], false, null, { sortable: true });
        renderSimpleTable("gapsTable", ["date", "type", "gap_low", "gap_high"], payload.gaps || [], false, null, { sortable: true });
        renderSimpleTable("trendlinesTable", ["type", "touch_count", "score", "last_touch_date"], payload.trendlines || [], false, null, { sortable: true });
        renderSimpleTable("patternsTable", ["pattern", "status", "confidence", "start_date", "end_date"], payload.patterns || [], false, null, { sortable: true });
        renderSimpleTable(
          "hybridPatternsTable",
          ["pattern", "status", "hybrid_confidence", "base_confidence", "candle_score", "volume_score", "breakout_score", "candle_bias", "vol_ratio", "start_date", "end_date"],
          payload.hybrid_patterns || [],
          false,
          null,
          { sortable: true }
        );
        renderSimpleTable(
          "cvProxyPatternsTable",
          ["pattern", "status", "cv_confidence", "method", "start_date", "end_date", "notes"],
          payload.cv_proxy_patterns || [],
          false,
          null,
          { sortable: true }
        );
        renderSimpleTable(
          "hybridCvCompareTable",
          ["pattern", "hybrid_status", "cv_status", "hybrid_confidence", "cv_confidence", "consensus_confidence", "agreement", "confidence_gap"],
          payload.hybrid_cv_compare || [],
          false,
          null,
          { sortable: true }
        );
        renderSimpleTable(
          "patternOverlaysTable",
          ["source", "class_name", "status", "confidence", "start_date", "end_date"],
          payload.pattern_overlays || [],
          false,
          null,
          { sortable: true }
        );
        renderSimpleTable("candlesTable", ["date", "pattern", "bias", "confidence", "explanation"], payload.candlestick_patterns || [], false, null, { sortable: true });
        renderSimpleTable("yoloPatternsTable", ["timeframe", "pattern", "confidence", "x0_date", "x1_date", "y0", "y1", "as_of_date"], payload.yolo_patterns || [], false, null, { sortable: true });
        $("chartStatus").textContent = `asof ${payload.asof || "-"} • ${ticker}`;
        setGlobalStatus(`Done (${ticker})`);
      } catch (err) {
        console.error(err);
        $("chartStatus").textContent = `Failed: ${err.message}`;
        setGlobalStatus(`Failed (${ticker})`);
      } finally {
        btn.disabled = false;
      }
    }

    async function loadTickerUniverse() {
      const base = getApiBase();
      try {
        const resp = await apiFetch(`${base}/api/tickers?limit=2000`);
        if (!resp.ok) throw new Error(`${resp.status}`);
        const payload = await resp.json();
        const list = $("tickerList");
        if (!list) return;
        list.innerHTML = "";
        (payload.tickers || []).forEach((t) => {
          const opt = document.createElement("option");
          opt.value = t;
          list.appendChild(opt);
        });
      } catch (err) {
        console.warn("ticker universe load failed", err);
      }
    }

    function loadTickerQuick(t) {
      $("ticker").value = t;
      activateTab("chart");
      loadChart();
    }

    async function loadReport() {
      const base = getApiBase();
      $("reportStatus").textContent = "Loading...";
      try {
        const resp = await apiFetch(`${base}/api/admin/daily-report?limit=20`);
        if (!resp.ok) throw new Error(`${resp.status} ${await resp.text()}`);
        const data = await resp.json();
        const latest = data.latest || {};
        const counts = latest.counts || {};
        const yoloBlock = latest.yolo || {};
        const yoloSummary = yoloBlock.summary || {};
        const ingestRun = latest.latest_ingest_run || {};
        const signals = latest.signals || {};
        const hasReport = data.ok && Object.keys(latest).length > 0;

        $("reportNoData").style.display = hasReport ? "none" : "block";
        if (!hasReport) { $("reportStatus").textContent = "No report yet"; return; }

        const makeCard = (label, val) =>
          `<div class="card"><div class="label">${label}</div><div class="value">${val ?? "—"}</div></div>`;

        $("reportSummaryCards").innerHTML = [
          makeCard("Generated (UTC)", (latest.generated_ts || "—").slice(0, 16).replace("T", " ")),
          makeCard("Tracked Tickers", counts.tracked_tickers ?? "—"),
          makeCard("Price Rows", (counts.price_rows ?? 0).toLocaleString()),
          makeCard("Latest Price Date", (latest.latest_data || {}).price_date ?? "—"),
          makeCard("Last Ingest", ingestRun.status ?? "—"),
        ].join("");

        const tfDaily  = (yoloBlock.timeframes || []).find(t => t.timeframe === "daily")  || {};
        const tfWeekly = (yoloBlock.timeframes || []).find(t => t.timeframe === "weekly") || {};
        $("reportYoloCards").innerHTML = [
          makeCard("YOLO Total Rows", yoloSummary.rows_total ?? "—"),
          makeCard("YOLO Tickers", yoloSummary.tickers_with_patterns ?? "—"),
          makeCard("Daily Tickers", tfDaily.tickers_with_patterns  ?? "—"),
          makeCard("Weekly Tickers", tfWeekly.tickers_with_patterns ?? "—"),
        ].join("");

        // 52W extremes
        const nearHigh = signals.near_52w_high || [];
        const nearLow  = signals.near_52w_low  || [];
        const fmt52w = (arr, field, refField, color) =>
          arr.length
            ? arr.map(t =>
                `<span style="display:inline-block; margin-right:10px;">` +
                `<b style="cursor:pointer; color:var(--blue);" onclick="jumpToTicker('${t.ticker}')">${t.ticker}</b> ` +
                `<span style="color:var(--fg)">$${t.close}</span> ` +
                `<span style="color:var(--muted); font-size:0.75rem;">(${t[field].toFixed(2)}% from ${refField} $${t[refField === 'high_52w' ? 'high_52w' : 'low_52w']})</span>` +
                `</span>`
              ).join("")
            : `<span style="color:var(--muted)">None</span>`;

        $("report52wHigh").innerHTML = nearHigh.length
          ? nearHigh.map(t =>
              `<span style="display:inline-block; margin-right:12px; margin-bottom:2px;">` +
              `<b style="cursor:pointer; color:var(--blue);" onclick="jumpToTicker('${t.ticker}')">${t.ticker}</b> ` +
              `<span>$${t.close}</span> ` +
              `<span style="color:var(--muted); font-size:0.75rem;">(${t.pct_from_high.toFixed(2)}% below $${t.high_52w})</span>` +
              `</span>`
            ).join("")
          : `<span style="color:var(--muted)">None</span>`;

        $("report52wLow").innerHTML = nearLow.length
          ? nearLow.map(t =>
              `<span style="display:inline-block; margin-right:12px; margin-bottom:2px;">` +
              `<b style="cursor:pointer; color:var(--blue);" onclick="jumpToTicker('${t.ticker}')">${t.ticker}</b> ` +
              `<span>$${t.close}</span> ` +
              `<span style="color:var(--muted); font-size:0.75rem;">(${t.pct_from_low.toFixed(2)}% above $${t.low_52w})</span>` +
              `</span>`
            ).join("")
          : `<span style="color:var(--muted)">None</span>`;

        // Top YOLO patterns at close
        renderSimpleTable("reportYoloTopTable",
          ["ticker", "timeframe", "pattern", "confidence", "x0_date", "x1_date"],
          signals.yolo_top_today || [],
          false, null, { sortable: false });

        // Candle signals at close
        renderSimpleTable("reportCandleTable",
          ["ticker", "pattern", "bias", "confidence"],
          signals.candle_patterns_today || [],
          false, null, { sortable: false });

        renderSimpleTable("reportHistoryTable",
          ["file", "size_bytes", "modified_ts"],
          data.history || [],
          false, null, { sortable: false });

        $("reportStatus").textContent = `As of ${(latest.generated_ts || "").slice(0, 16).replace("T", " ")} UTC`;
      } catch (err) {
        $("reportStatus").textContent = `Error: ${err.message}`;
        console.error(err);
      }
    }

    function setChartTimeframe(tf) {
      CHART_TIMEFRAME = tf;
      $("tfDailyBtn").style.background  = tf === "daily"  ? "var(--blue)" : "var(--card)";
      $("tfDailyBtn").style.color        = tf === "daily"  ? "#fff"        : "var(--muted)";
      $("tfDailyBtn").style.border       = tf === "daily"  ? "none"        : "1px solid var(--border)";
      $("tfWeeklyBtn").style.background  = tf === "weekly" ? "var(--blue)" : "var(--card)";
      $("tfWeeklyBtn").style.color        = tf === "weekly" ? "#fff"        : "var(--muted)";
      $("tfWeeklyBtn").style.border       = tf === "weekly" ? "none"        : "1px solid var(--border)";
      if (LAST_CHART_PAYLOAD) renderChart(LAST_CHART_PAYLOAD);
    }

    $("loadOpBtn").addEventListener("click", loadOpportunities);
    $("presetAllBtn").addEventListener("click", () => applyOpportunityPreset("all"));
    $("presetUndervaluedBtn").addEventListener("click", () => applyOpportunityPreset("undervalued"));
    $("presetDeepValueBtn").addEventListener("click", () => applyOpportunityPreset("deep_value"));
    $("presetOvervaluedBtn").addEventListener("click", () => applyOpportunityPreset("overvalued"));
    $("presetResetBtn").addEventListener("click", () => applyOpportunityPreset("reset"));
    $("clearOpSearchBtn").addEventListener("click", () => {
      if ($("opSearch")) $("opSearch").value = "";
      loadOpportunities();
    });
    $("loadChartBtn").addEventListener("click", loadChart);
    $("tfDailyBtn").addEventListener("click", () => setChartTimeframe("daily"));
    $("tfWeeklyBtn").addEventListener("click", () => setChartTimeframe("weekly"));
    window.addEventListener("keydown", (e) => { if (e.key === "Enter") loadChart(); });
    $("showTrendlines").addEventListener("change", () => { if (LAST_CHART_PAYLOAD) renderChart(LAST_CHART_PAYLOAD); });
    $("showPatterns").addEventListener("change", () => { if (LAST_CHART_PAYLOAD) renderChart(LAST_CHART_PAYLOAD); });
    $("showRuleClassLines").addEventListener("change", () => { if (LAST_CHART_PAYLOAD) renderChart(LAST_CHART_PAYLOAD); });
    $("showCvClassLines").addEventListener("change", () => { if (LAST_CHART_PAYLOAD) renderChart(LAST_CHART_PAYLOAD); });
    $("showYoloPatterns").addEventListener("change", () => { if (LAST_CHART_PAYLOAD) renderChart(LAST_CHART_PAYLOAD); });

    (async () => {
      activateTab("guide");
      await initApiBase();
      await initApiKey();
      await refreshServiceStatus();
      await loadTickerUniverse();
      await loadOpportunities();
      setInterval(refreshServiceStatus, 60000);
    })();
  </script>
</body>
</html>
